<h1>부록 A.</h1>
<h3>추상화 기법</h3>
<ol>
<li><p>분류와 인스턴스화</p>
<ul>
<li>분류는 공통적인 특성을 기반으로 범주를 형성하는 것</li>
<li>인스턴스화는 분류의 역으로 객체를 생성하는 과정</li>

</ul>
</li>
<li><p>일반화와 특수화</p>
<ul>
<li>일반화는 범주의 차이를 숨기고 공통적 특성을 강조하는 것</li>
<li>일반화의 역이 특수화</li>

</ul>
</li>
<li><p>집합과 분해</p>
<ul>
<li>집합은 부분과 관련된 세부사항을 숨기고 전체를 형성하는 것</li>
<li>분해는 전체를 부분으로 분리하는 것</li>

</ul>
</li>

</ol>
<br>
<p>  </p>
<h4>분류와 인스턴스화</h4>
<h5>개념과 범주</h5>
<p>개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념 혹은 아이디어이다.</p>
<p>객체지향에서 개념을 가리키는 표준 용어는 <strong>타입</strong>이다.</p>
<p>이런 관점에서 객체를 타입의 <strong>인스턴스</strong>라고 한다.</p>
<p>  </p>
<br>
<h5>타입</h5>
<p>타입은 객체를 분류하는 장치로써 적용할 수 있으며 필요조건은 다음과 같다.</p>
<p><strong>심볼</strong>: 타입을 가리키는 간략한 이름이나 명칭</p>
<p><strong>내연</strong>: 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.</p>
<p><strong>외연</strong>: 타입에 속하는 모든 객체들의 집합</p>
<blockquote><p>심볼은 클래스의 이름을 의미한다고 볼수 있지 않을까?</p>
<p>내연은 클래스의 구성요소? instanceof 로 검사했을때 true를 받으면 내연이 일치한다고 볼수 있는게 아닐까?</p>
</blockquote>
<p>  </p>
<br>
<h5>외연과 집합</h5>
<p>타입의 외연은 타입에 속하는 객체들의 집합이다.</p>
<p>즉 집합의 다른말이 외연이다.</p>
<p>단일 분류와 다중 분류</p>
<p>단일 분류는 하나의 타입에만 속하는 것이고, 다중 분류는 여러 타입에 속하는 것을 의미한다.</p>
<p>다중 상속과 혼동해서는 안된다. 하나의 객체가 서로 다른 타입의 인스턴스가 되는것을 의미한다.</p>
<blockquote><p>그렇다면 자바에서 상속과 인터페이스를 동시에 받는 경우를 생각하면 되는 것일까?</p>
</blockquote>
<p>  </p>
<br>
<p>객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 이를 <strong>동적 분류</strong>라고 한다.</p>
<p>변경할 수 없는 경우는 <strong>정적 분류</strong>라 한다.</p>
<blockquote><p>잘 이해가 되지 않는다. 슈퍼 클래스에서 다운 캐스팅 하는것을 의미하는 것인가?</p>
</blockquote>
<p>  </p>
<br>
<p>다중 분류와 동적 분류는 서로 배타적인 개념이 아니다. 개념적인 관점에서 다중 분류와 동적 분류를 함께 적용한 것이 실세계를 모델링하는 데 유용하다.</p>
<p>우리가 사용하는 대부분으 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법은 제공하지 않는다.</p>
<blockquote><p>&#39;ArrayList가 LinkedList가 되는 방법을 제공하지 않는다.&#39; 와 같이 봐도 되는 것인가?</p>
<p>그렇다면 위에서 이해가 안된 점이 해소가 될 듯 하다.</p>
<p>아마 동적 변수같은 것을 의미하는 것이 아닐까? 자바스크립트의 var 같이?</p>
</blockquote>
<p>  </p>
<br>
<h5>클래스</h5>
<p>객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법ㄴ은 클래스를 이용하는 것이다.</p>
<p>&#39;타입을 구현한다&#39;라고 표현한 이유는 클래스와 타입이 동일한 개념이 아니기 때문이다.</p>
<p>클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다.</p>
<p>인스턴스를 생성할 수 없는 추상 클래스, 인터페이스도 타입을 구현할 수 있다.</p>
<blockquote><p>위에서 잘못 생각했었다.</p>
<p>타입을 좀더 큰 범위에서 포장하고 있는 개념이 클래스였다.</p>
<p>&#39;클래스는 타입이다.&#39;는 타당할 수 있어도 역인 &#39;타입은 클래스이다.&#39; 는 성립하지 않는다.</p>
</blockquote>
<p>  </p>
<br>
<h4>일반화와 특수화</h4>
<h5>범주의 계층</h5>
<p>일반적인 범주는 계층의 상위에 존재하고, 특수한 범주는 계층의 하위에 존재한다.</p>
<p>따라서 계층의 상위에 존재하는 범주를 하위에 위치한 범주의 일반화라 한다. 그리고 그 반대는 특수화라 한다.</p>
<p>  </p>
<h5>서브타입</h5>
<p>일반적인 타입을 이용해 좀 더 세부적인 타입을 정의함으로써 타입 간의 계층 구조를 구축할 수 있다.</p>
<p>어떤 타입이 다른 타입보다 일반적이라면 이 타입을 <strong>슈퍼타입</strong>이라고 한다. (<strong>일반화</strong>)</p>
<p>어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 <strong>서브타입</strong>이라고 한다. (<strong>특수화</strong>)</p>
<p>이 같은 일반화의 특징을 이용하면 부분적인 사실을 통해 복잡한 사실에 대한 논리적인 추론이 가능해진다.</p>
<p>  </p>
<br>
<p>어떤 타입이 다른 타입의 서브타입이 되기 위해서는 &#39;Is-a 규칙&#39;을 준수해야 한다고 말한다.</p>
<p>Is-a 규칙은 타입의 외연과 관련된 규칙이다. 이 관계를 만족하지 못할 경우 두 타입간에 일반화 관계는 성립하지 않는다.</p>
<p><strong>Is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다.</strong></p>
<p>  </p>
<br>
<h5>상속</h5>
<p>가장 일반적인 방법의 일반화와 특수화 관계를 구현한 것.</p>
<p>하지만 모든 상속 관계가 일반화 관계인 것은 아니다.</p>
<blockquote><p>왜 인지 반례가 생각나지 않는다.</p>
</blockquote>
<p>  </p>
<br>
<p>일반화의 원칙은 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야 한다는 것이다.</p>
<p>순응은 <strong>구조적인 순응</strong>과 <strong>행위적인 순응</strong> 두 가지 종류가 있다.</p>
<p>두 가지 순응 모두 서브타입의 슈퍼타입에 대한 <strong>대체 가능성</strong>을 의미한다.</p>
<p>구조적인 순응의 경우 기대 집합은 속성과 연관관계에 관한 것이며,</p>
<p>행위적인 순응의 경우 기대 집합은 행위가 동일한 계약을 기반으로 하느냐이다.</p>
<p>  </p>
<br>
<p>구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다.</p>
<p>즉, 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.</p>
<blockquote><p>상속의 관계를 말하는 것 같다.</p>
</blockquote>
<p>  </p>
<br>
<p>행위적인 순응은 타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다.</p>
<p>이는 <strong>리스코프 치환 원칙(LSP)</strong>이라고 한다.</p>
<blockquote><p>인터페이스를 의미하는 것 같다.</p>
<p>여기서 말한 상속이 자바의 상속을 의미하는게 아니고 개념적인 의미의 상속이었던 것 같다.</p>
</blockquote>
<p>  </p>
<br>
<p>상속은 서브 타이핑과 서브 클래싱으로 사용된다.</p>
<p>서브 타이핑은 인터페이스 상속이라고하며, 서브 클래싱은 구현 상속이라고 한다.</p>
<p>  </p>
<br>
<h4>집합과 분해</h4>
<h5>계층적인 복잡성</h5>
<p>복잡성은 계층의 형태를 띤다.</p>
<p>단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 &#39;안정적인 형태&#39;의 수와 분포에 의존한다.</p>
<blockquote><p>작은 안정적인 형태의 조합으로 연쇄적 계층 구조가 형성된다.</p>
</blockquote>
<p>  </p>
<br>
<p>안정적인 형태의 부분으로부터 전체를 구축하는 행위를 <strong>집합</strong>이라 한다.</p>
<p>따라서 반대의 행위는 <strong>분해</strong>가 된다.</p>
<p>이러한 방식으로 집합을 이루어 생성된 계층 구조는 재귀적인 설계를 가능하게 한다.</p>
<blockquote><p>재귀적인 설계라 함은 메세지의 위임을 통해 책임을 수행하는 것을 말하는 것인가?</p>
</blockquote>
<p>  </p>
<br>
<p>집합은 전체의 내부로 불필요한 세부사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.</p>
<p>집합은 한 번에 다뤄야 하는 요소의 수를 감소시킴으로써 인지 과부하를 방지한다.</p>
<p>  </p>
<br>
<h5>합성관계</h5>
<p>객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 <strong>합성 관계</strong>를 사용한다.</p>
<p>다수의 주문으로 이루어진 주문항목은 사용자로 하여금 모든 주문에 대해 인지할 필요가 없게함으로써</p>
<p>다시말해 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.</p>
<p>하지만 상품이 주문이 되는 관계는 상품이 주문 항목의 일부가 아니기 때문에 합성 관계가 아닌 <strong>연관 관계</strong>이다.</p>
<p>합성 관계에 있는 객체는 포함하는 객체(주문)이 제거되면 내부에 포함된 객체(주문항목)도 함께 제거된다.</p>
<blockquote><p>여러가지 케이스가 생각이 나는데 반대로 주문항목이라는 것이 사라져도 주문이 사라지는 역도 성립하지 않을까?</p>
<p>그리고 주문이 N이고 주문 항목이 1인 다대일 관계인데, 주문이 사라진다고 무조건 주문항목이 사라지는건 아니지 않은가?</p>
</blockquote>
<p></p>
<br>
<h5>패키지</h5>
<p>구조에 관한 큰 그림을 안내해 줄 지도의 역할이다.</p>
<p>소프트웨어의 전체적인 구조를 논리적 단위로 묶는 구성요소를 <strong>패키지</strong> 또는 <strong>모듈</strong>이라고 한다.</p>
<p>응집도가 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 적어진다.</p>
