### 추상화 기법의 종류

1)분류와 인스턴스화 분류
분류 = 공유 특징 기반으로 범주
잉스턴스화 = 범주로부터 객체를 생성
2)일반화와 특수화
일반화 = 범주 차이를 숨기고 공통만을 강도
특수화 = 일반화의 역
3)집합과 분해
집합 = 부분관련 세부사항 숨기고 전체 형성
분해 = 전체를 부분으로

### 개념과 범주

객체들의 특정 집합에 공통의 개념을 적용한다 = 객체를 범주로 묶는다.
범주와 개념은 인간이 실세계를 바라보는 인식의 형태를 빚는다.
분류 = 객체에 개념을 적용하는 과정
범주로 묶는건 복잡성을 낮출 수 있거
객체=수많은 개별적인 현상들
타입=하나의 개념
분류 = 객체를 타입과 연관시키는 것
인스턴스화, 예시 = 타입에 해당하는 객체를 생성 (분류의 반대)
개념=타입
객체=타입의 인스턴스

### 타입

타입을 정의하기위한 세가지
1)심볼 - 타입을 가리키는 간략한 이름이나 명칭
2)외연 - 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부 확인가능
3)내연 - 타입에 속하는 모든 객체들의 집합

### 외연과 집합

집합=외연
단일분류 = 한 객체가 한 시점에 하나의 타입에만 속하는 것
다중 분류 = 한 객체가 여러 타입에 속하는 경우

> 객체지향 프로그래밍 언어는 단일 분류만을 지원

객체가 타입을 변경할 수 있다면?
1)동적분류 = 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입 변경 가능 (상속에서 부모클래스 타입일때인가?)
2)정적분류 = 객체가 자신의 타입을 변경할 수 없는 경우
동적분류 쉽지않다 - 디자인템플릿 > but: 단일 분류와 동적분류를 선택하자! 

### 클래스

타입을 구현한다
코드를 재사용한다
클래스가 없는 프로토타입 언어에서 분류와 인스턴스화는 프로토 타입이란 객체의 복사로 이루어짐

### 범주의 계층

세부 = 하위 계층
일반 = 상위 계층
일반 -> 세부 : 특수화
세부 -> 일반 : 일반화

### 서브타입

일반화 특수화 : 계층구조 안에 존재하는 타입간 관계
슈퍼타입 : 어떤타입이 다른 타입보다 일반적
서브타입 : 어떤타입이 다른 타입보다 특수
서브타입은 슈퍼타입의 속성 + 자신만의 추가적인 속성
서브타입은 슈퍼타입의 부분집합 
Is_a 규칙 / 100%규칙

### 상속

일반화와 특수화 관계 구현의 가장 일반적인 방법
( 그러나 상속이 반드시 일반화 관계는 아님)
1)구조적인 순응: 타입의 내연과 관련된 100% 규칙 - 서브타입은 슈퍼타입이 가지는 속성과 연관관계에 있어서 100프로 일치해야한다.
2)행위적인 순응: 리스코프 치환 원칙
서브타입은 슈퍼타입응 행위적으로 대체가능해야한다.
상속의 용도 두가지
1)서브타이핑: 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 - 유연성 (인터페이스 상속)
2)서브클래싱: 서브클래스가 슈퍼클래스를 대체할 수 없는 경우 - 코드 중복 재사용 (구현 상속)
클래스간의 위임 = 어떤 객체의 클래스가 메시지 이해 못하면 부모 클래스에 메시지를 위임

### 계층적인 복합성 - 시계 이야기

-복잡성은 계층의 형태를 띈다
-단순한 형태로부터 복잡한 형태로 진화하는데 걸리는 시간은 그 사이애 존재하는 안정적인 형태의 수와 분포에 의존
집합 : 안정적인 형태의 부분으로부터 전체를 구축하는 행위
분해 : 전체를 부분으로 분할하는 행위

> 한번에 다루어야 하는 요소의 수를 감소시킨다.

### 합성관계

객체와 객체사이의 전체-부분 관계 구현을 위해서는 합성관계를 사용한다.
부분을 전체안에 캡슐화 해서 인지 과부화를 방지
주문에서 주문이 주문 항목의 존재를 일시적으로 감추어 복잡성을 낮춘다.
연관관계 - 주문과 상품사이
합성관계 - 주문과 주문 항목 사이
합성관계는 연관관계보다 객체를 더 강하게 결합
-) 연관이 없어져도 객체는 살아있기 때문

### 패키지

관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성요소 (모듈, 패키지)
합성관계가 내부에 포함된 객체의 존재를 감춰서 내부 구조를 추상화
패키지가 내부에 포함된 클래스들을 감춰서 시스템의 구조를 추상화
