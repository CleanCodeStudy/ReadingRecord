# 7. 함께 모으기

### 1.  커피 전문점

엇근데 메뉴항목 객체랑 커피객체랑 연간이 띄어져 있어서 음,, 실제 코드레벨로 생각하면 겹치는 부분일 것 같은데..! 

인자값이랑 명령이랑 리턴값을 이렇게 표현한게 너무 귀엽다ㅋㅋㅋ

명령 (메소드)은 화살표의 끝 점에 있는 곳의 객체가 갖고있다.

이 메소드들은 외부에서 접근이 가능해야하므로 public으로 되어 있어야한다.

이 메소드들의 return 타입은 그린 UML의 return 타입에 의해 결정된다.



Customer가 원하는게 연쇄적으로 이뤄지기 위해서, 명령이라는 주문이 연쇄적으로 일어나느 여러 객체에 대한 참조를 알아야한다. > 인자 값으로 넣어버려서 해결함

인자 값으로 넣고,  해당하는 인자 값의 명령을 수행한다.

Customer (String menuName, Menu menu, Barista barista){

​	MenuItem = menu.choose(menuName);

​	Coffee coffe = barista.makeCoffee(menuItem);

}

음,, 책에서 여러 객체에 대한 참조를 하는 여러 방법이 있다고 했는데 스프링이라면 
 menu와 barista의 의존성을 주입하는 방법도 하나의 방법이겠다 라는 생각이 드는군

> clean code 법칙 메소드에 인자를 3개 이상 넣지 말아라



설계가 머리에 잘 안그려진다면 스스로 코드를 짜면서 전체적인 밑그림 시작해라 > 테스트-주도 설계로 코딩을 하는 사람들



-> 초반에 했던 메뉴 아이템과 커피에 대한 생각

나는 MenuItem과 Coffee가 같은 속성을 지닌다고 생각해서 (실제로도 저자가 코드를 구현한 부분을 보면 Coffee는와 MenuItem의 멤버변수의 수나 종류 모두 같다) 겹친다고 생각했는데, 

저자가 구현한 부분을 보니 음,,, 같은 멤버변수를 가질 지라도, Barista 객체가 MenuItem을 받아서 Coffee 객체를 생성한다는 점에서 좀더 실세계가 코드레벨로 잘 구현이 된 것같은 생각이 들었다.

내가 원래 생각한건 MenuItem객체가 Menu 안에 있고, Barista 객체가 order 받은 MenuItem객체를 return 하는거였는데, 음 Class 명으로 생각을 해보니까 그렇게 구현하면 커피를 주문을 했는데 정작 Customer에게 주는 건 Menu에 대한 정보를 준다?! 일 것 같아서ㅋㅋㅋ 

"같은 멤버변수를 가지더라도, 그 객체가 하는 역할에 따라 분리하자"



### 2. 코드의 세가지 관점

#### 2-1. 개념관점

도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.

사용자가 도메인을 바라보는 관점을 반영함 : 실제 도메인 규칙을 최대한 반영하는 것이 중요

##### 클래스가 은유하는 개념

> 클래스인 Customer, Menu, MenuItem, Barista, Coffee - 실제 커피 전문점의 도메인 개념을 반영한다.
>
> 실제로 Coffee를 제조하는 과정을 변경한다면 Coffee 객체를 만들어내는 Barista 클래스를 변경해야하는 것처럼 실 세계 반영이 잘 되어 있다.



#### 2-2. 명세관점

사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어에 초점이 맞춰진다. (객체의 관점 : 객체의 인터페이스 관점)

객체가 협력을 위해 '무엇'을 할 수 있는가에 초점

즉, 프로그램의 한 로직에 참여할 때 사용되는 객체의 method 에 초점이 맞춰지는 듯

이때 중요한건 구현과 인터페이스를 분리하는 것

##### 클래스의 공통 인터페이스

> 변화에 탄력적인 인터페이스 만들기 
>
> public 메서드 : 다른 객체와의 협력이 가능하다 -> 외부 객체가 해당 객체에 접근이 가능한 유일한 수단이다! 
>
> public 메서드의 역할에 따라, 다른 객체가 이 객체에 미칠 수 있는 영향을 계산 할 수 있을 것



#### 2-3. 구현관점

객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것.

객체의 책임을 '어떻게' 수행 할 것인가

인터페이스 구현에 필요한 속성과 메소드를 작성한다.

##### 클래스의 속성과 메소드

> 메소드와 속성은 외부 객체에 의해서 혹은 외부 객체에 영향을 미치면 안된다. 확실한 캡슐화가 이루어 져야하기 때문!!
>
> 롬복의 @Data를 지양하는 이유인 것 같다.



이 코드의 세가지 관점을 모두 포현하는 코드를 작성하는게 훌륭한 프로그래머 이다.

> 개념-명세의 분리는 그렇게 중요하지 않을 수 있지만
>
> 명세-구현의 분리는 엄청 중요하다.
>
> 인터페이스와 구현이 명확해야하고, 캡슐화 규칙을 위반해서도 안된다.