제네릭 아이템26,27,28
=================

   로타입은 사용하지 마라
   ----------------
   
   * 로타입은 제네릭을 사용하지 않고 List list의 형태로 사용하는 것이다.
     이 방식은 제네릭을 지원하지 않았을때와의 호환성때문에 어쩔 수 없이 유지중이다. 사용하지 않는것이 좋다.
     로타입은 컴파일 단에 타입에 자유롭고 런타임때 에러를 뱉는다. 데이터를 꺼낼때 ClassCastException을 던진다. 
    
     
   * 제네릭을 사용하면 컴파일 단계에서 타입체크를 하고 런타임때는 타입정보를 다 날린다. 
     그렇다면 어떻게 캐스팅을 안해도 데이터를 꺼낼 수 있을까? 컴파일러가 보이지 않는 형변환을 추가하여 절대 실패하지 않도록 보장한다.
     
   <pre>
    <code>
       @Test
        @DisplayName("로타입 사용법")
        void name3() {
            //given
    
            //when
            List<String> strings = new ArrayList<>();
            int test = 0;
            add(strings,test);
            assertThatThrownBy(()->strings.get(0))
                    .isInstanceOf(ClassCastException.class);
    
    
            //then
    
        }
    
        private void add(List list,Object o){
            list.add(o);
        }
       }
    </code>
   </pre>
     
   
   * 로타입에는 아무 원소나 넣을 수 있다. 하지만 타입 불변식을 훼손하기 쉽다. 반면 비한정적 와일드카드는 값을 넣을 수 없으므로(null 제외)
     안전하다. 로타입처럼 타입에 구애받지 않고 자유롭게 사용하고 싶은때는 비한정적 와일드카드를 써라.
     
     
   
   * List<String>.class와 List<?>.class는 허용되지 않는다. 배열은 가능.
     instanceof는 로타입으로 컬렉션의 타입을 검사가능하다. 그다음 와일드 카드타입으로 형변환 가능
     
     
   * 한정적 타입 매개변수와 한정적 와일드카드 타입은 뭐가다를까?
     
     
     
   비검사 경고를 제거하라
   ----------------
   
   * 타입이 안전하다는 확신이 든다면 @SuppressWarnings를 사용하여 경고를 제거하라
     하지만 범위를 너무 크게잡진 마라, 다른경고도 제거된다. -> 인텔리제이 노란줄로 경고해준다. 그때 사용하도록
     
     
   배열보단 리스트
   ---------------- 
     
   * 배열보단 리스트를 사용해야한다. 첫째 배열은 공변이다. 어떤클래스가 상속관계면 배열도 그렇게된다. 하지만 제네릭은 타입이다. 공변이 안된다.
     공변은 생각보다 중요하다. 컴파일단계에서 일어날 수 있는 실수를 잡아준다.
    
    
   * 제네릭 배열은 지원안된다. 그 이유는 런타임에 예외상황이 체크가능하다. 165p 예제확인
   
   * 가변인수 메서드를 제네릭으로 만들면 경고가뜬다. @SafeVarags로 해결
   
   
   *계산기 문제,toString문제 만들기.
   

     



